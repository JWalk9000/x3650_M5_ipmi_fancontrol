#!/usr/bin/perl
use strict;
use warnings;
use List::Util qw[min max];

# IBM x3650 Port notes: This port was made in an attempt to quiet down an IBM system x3650 M4.
#                       The porting involved changing the raw commands, removing the get GetFanRPM as it was
#                           useless in my scenario and IBM lists their fans as 1A 1B 2A 2B.
#                       Also the imm2 mantains a partial control over the fans actual speed, for example setting
#                           the fans at 30% result in an actual fan speed of roughly 24%, sometimes the script
#                           fails to update and the imm2 takes control back over the fans speed controls. 
#                       Overall the real speed settings feels very coarse.

# This script controls IPMI compatible server's fan speeds in response to CPU Temperatures provided by lm-sensors.
# This script has been tested on a Dell PowerEdge R210 II, but should work on any IPMI compatible server.
#
# NOTE: The script puts your server into "Full Fan Speed Mode", and then modifies what "Full Speed" means,
#       You have to manually use IPMI to set it to e.g. "Optimal" when you're not using the script.
#
# NOTE: You use this script at your own risk, and no warranty is provided. Do not use in produciton environments.
#
# Maintainer: Brian Wilson <brian@wiltech.org>
# Original Author: Layla Mah <layla@insightfulvr.com>
# Original Version: https://github.com/missmah/ipmi_tools
#
# What's new?
#
# The original script provided a "step" approach where fans would take large "steps" depending on the temps.
# In this version, scalar equations are generated to provide an easy (and quiet) slope to follow to the next step.
# These equations are simple Y=mx+b linear slopes that effectivly provide a fan "curve" based on the entries in the
# %cpu_temp_to_fan_speed hash table.
#
# More documentation is planned, however I am available to answer basic configuration questions in the mean time.

# System Configuration
my $hostname            = `hostname`;
# Remove line ending from $hostname
$hostname =~ s/\n//g;

my $number_of_cpus         = 2; # Number of CPUs to search for
#my $number_of_gpus        = 4; # Number of GPUs to search for
my $number_of_fans         = 6; # Number of FANs to search for
my $number_of_fanbanks     = 2; # Number of BANKs of FANs to update
#my $number_of_fanbanks    = 2; # Number of BANKs of FANs to update
my $min_temp_change        = 0; # *C minimum change to actually cause a fan speed update
my $seconds_to_sleep       = 2; # Number of seconds to sleep between update loops (lower = tighter control)

# Control Resilience & Diagnostics (IBM IMM2 quirks)
my $min_duty               = 25;   # Minimum duty to request (0-255). Too low can trigger IMM2 ramp-up
my $max_duty               = 250;  # Maximum duty to request (0-255)
my $refresh_period_secs    = 8;    # Reassert fan command at least this often even if temps haven't changed
my $enable_diagnostics     = 1;    # Print periodic diagnostics (SEL, SDR, RPMs)
my $diagnostics_every_loops= 10;   # Emit diagnostics every N control loops
my $override_rpm_threshold = 8000; # If RPM exceeds this while asking for a low duty, assume IMM2 override
my $override_duty_threshold= 80;   # If desired duty is below this and RPM is very high, treat as override
my $rpm_deviation_threshold= 2000; # If RPM jumps by this much unexpectedly, flag

# IPMI Configuration
#my $ipmi_username       = "username_goes_here";
#my $ipmi_password       = "password_goes_here";
#my $ipmi_ipaddress      = "ip_address_goes_here";
my $ipmi_cmd_listall    = "sdr list full";
#my $ipmi_connectmode    = "open";
my $ipmi_preamble       = "ipmitool";

# Not needed as it's running directly on proxmox as a service
#my $ipmi_preamble       = "ipmitool -I $ipmi_connectmode"; 
#my $ipmi_preamble       = 'ipmitool -I $ipmi_connectmode -U $ipmi_username -P $ipmi_password -H $ipmi_ipaddress';

# CPU Temp -> Fan Speed Mappings
my %cpu_temp_to_fan_speed;
$cpu_temp_to_fan_speed{80} = 250;
$cpu_temp_to_fan_speed{70} = 150;
$cpu_temp_to_fan_speed{55} = 50;
$cpu_temp_to_fan_speed{40} = 25;
$cpu_temp_to_fan_speed{10} = 5;

my %cpu_temp_scale;

# Below this line follows the actual implementation of the script

my $g_current_fan_duty_cycle = 0;
my $g_current_gpu_temp = 0;
my $g_current_cpu_temp = 0;
my $g_last_set_cpu_temp = 0;
my $g_last_set_gpu_temp = 0;
my $g_last_set_time_epoch = 0;      # Last time we issued a fan command
my $g_loops_since_diag = 0;         # Diagnostic cadence counter
my $g_last_max_rpm = 0;             # Last observed max RPM (for deviation detection)

sub ClampFanSpeed
{
    my ( $s ) = @_;
    $s = max($min_duty, $s);
    $s = max(0, $s);        # guard
    $s = min($max_duty, $s);
    return $s;
}

sub Internal_DoSetFanSpeed
{
    my ( $fan_speed ) = @_;

    $fan_speed = ClampFanSpeed($fan_speed);
    # Sets the speed for each individual fan
    for (my $i = 1; $i <= $number_of_fanbanks; $i++)
    {
        print "Setting FanBank nÂ°$i speed at $fan_speed\n";
        #ipmitool raw 0x3a 0x07 1 100 0
        `$ipmi_preamble raw 0x3a 0x07 $i $fan_speed 0x01> /dev/null 2>&1`;
    }
}

sub SetFanSpeed
{
    my ( $fan_speed ) = @_;

    my $cpu_temp_difference = $g_current_cpu_temp - $g_last_set_cpu_temp;
    my $gpu_temp_difference = $g_current_gpu_temp - $g_last_set_gpu_temp;
    my $now = time();
    my $time_since_last = $now - $g_last_set_time_epoch;

    my $should_refresh = ($refresh_period_secs > 0) && ($time_since_last >= $refresh_period_secs);

    if( $should_refresh or ( ( (abs $cpu_temp_difference) > $min_temp_change ) or ( (abs $gpu_temp_difference) > $min_temp_change ) ) )
    {
        # Set all 4 fan banks to operate at $fan_speed duty cycle (0x0-0x64 valid range)
        print "\n";
        print "********************** Updating Fan Speeds **********************\n";
        print "We last updated fan speed $cpu_temp_difference *C ago (CPU Temperature).\n";
        print "We last updated fan speed $gpu_temp_difference *C ago (GPU Temperature).\n";
        print "Current CPU Temperature is $g_current_cpu_temp *C.\n";
        print "Current GPU Temperature is $g_current_gpu_temp *C.\n";
        if ($should_refresh) { print "Reason: periodic refresh (" . $time_since_last . "s since last).\n"; }
        print "*****************************************************************\n";

        $g_last_set_cpu_temp = $g_current_cpu_temp;
        $g_last_set_gpu_temp = $g_current_gpu_temp;
        $g_current_fan_duty_cycle = $fan_speed;
        $g_last_set_time_epoch = $now;

        Internal_DoSetFanSpeed( $fan_speed );
    }
}

# Get current CPU temperature from lmsensors. If there are multiple CPU's,
# the script will automatically choose the highest temperature.
sub GetCPUTemp
{
    my $current_cpu_temp = 0;

    my $sensors_output = `sensors | grep "Package" | sed 's/.*:\\s*+\\(.*\\)  .*(.*/\\1/'`;
    my @vals = split("\n", $sensors_output);
    foreach my $value (@vals)
    {
        # Remove the *C from $sensors_output (and anything else thats not numbers or decimal points)
        my $cpu_temp = `echo $value | sed -e 's/[^0-9. ]*//g' -e 's/ \\+/ /g'`;
        $current_cpu_temp = max($cpu_temp, $current_cpu_temp);
    }
    # Remove trailing line endings
    $current_cpu_temp =~ s/\n//g;

    return $current_cpu_temp;
}

sub GetFanRPMStats
{
    # Returns (max_rpm, avg_rpm, count, \@rpms)
    my @rpms = ();
    my $sdr = `$ipmi_preamble sdr type Fan 2>/dev/null`;
    my @lines = split("\n", $sdr);
    foreach my $line (@lines) {
        # Example formats can vary, try to capture numeric RPM
        if ($line =~ /([0-9]{2,})\s*RPM/i) {
            push @rpms, $1 + 0;
        }
    }
    my $count = scalar @rpms;
    if ($count == 0) { return (0, 0, 0, \@rpms); }
    my $max_rpm = 0; my $sum = 0;
    foreach my $r (@rpms) { $max_rpm = $r if $r > $max_rpm; $sum += $r; }
    my $avg = sprintf('%.0f', $sum / $count);
    return ($max_rpm, $avg, $count, \@rpms);
}

sub MaybeEmitDiagnostics
{
    return if (!$enable_diagnostics);
    $g_loops_since_diag++;
    if ($g_loops_since_diag < $diagnostics_every_loops) { return; }
    $g_loops_since_diag = 0;

    print "\n----- Diagnostics -----\n";
    my ($maxrpm, $avgrpm, $count, $rpms_ref) = GetFanRPMStats();
    print "Fan tach count=$count, maxRPM=$maxrpm, avgRPM=$avgrpm\n";
    if ($count > 0) {
        my $rpmlist = join(',', @$rpms_ref);
        print "RPMs: [$rpmlist]\n";
    } else {
        print "No fan tach data available from SDR.\n";
    }
    my $sdr_info = `$ipmi_preamble sdr info 2>/dev/null`;
    print "SDR info: \n$sdr_info\n" if length($sdr_info);
    my $sel_tail = `$ipmi_preamble sel elist 2>/dev/null | tail -n 5`;
    print "SEL last 5 events:\n$sel_tail\n" if length($sel_tail);
    print "-----------------------\n\n";
}

sub CheckForOverride
{
    my ( $desired_fan_speed ) = @_;
    my ($maxrpm, $avgrpm, $count, $rpms_ref) = GetFanRPMStats();
    if ($count == 0) { return; }

    my $override_suspected = 0;
    if ( ($desired_fan_speed < $override_duty_threshold) && ($maxrpm >= $override_rpm_threshold) ) {
        $override_suspected = 1;
    }
    if ($g_last_max_rpm > 0 && ($maxrpm - $g_last_max_rpm) >= $rpm_deviation_threshold && $desired_fan_speed < $override_duty_threshold) {
        $override_suspected = 1;
    }
    $g_last_max_rpm = $maxrpm;

    if ($override_suspected) {
        print "[WARN] IMM2 override suspected: desired duty=$desired_fan_speed, maxRPM=$maxrpm. Reasserting command.\n";
        # Immediately reassert once to try to reclaim control
        Internal_DoSetFanSpeed( $desired_fan_speed );
        $g_last_set_time_epoch = time();
    }
}

sub CalculateScalars
{
    my @previous = ();
    foreach my $a (sort keys %cpu_temp_to_fan_speed){
        my @current = ($a, $cpu_temp_to_fan_speed{$a});

        if (@previous) {
            my $m = ($current[1] - $previous[1]) / ($current[0] - $previous[0]);
            my $b = $current[1] - ($m*$current[0]);

            $cpu_temp_scale{$a} = [($m, $b)];
        }

        @previous = @current;
    }
}

sub UpdateFanSpeed
{ 
    my $current_cpu_temp = GetCPUTemp();
    my $current_gpu_temp = 0;
    
    $g_current_cpu_temp = $current_cpu_temp;
    $g_current_gpu_temp = $current_gpu_temp;
    
    print "Maximum CPU Temperature Seen: $current_cpu_temp degrees C.\n";
    print "Maximum GPU Temperature Seen: $current_gpu_temp degrees C.\n";
    
    my $desired_fan_speed = 0;
    my $calculated_speed = 0;
    foreach my $a (reverse sort keys %cpu_temp_scale) {
        #print "A$a\n";
        if ($current_cpu_temp <= $a) {
            my @formula = @{$cpu_temp_scale{$a}};
            $calculated_speed = ($formula[0] * $current_cpu_temp) + $formula[1];
            #print "Test#2:$formula[0] $formula[1]\n";
            $desired_fan_speed = sprintf("%.0f", $calculated_speed);
        }
    }

    print "Current Fan Duty Cycle: $g_current_fan_duty_cycle%\n";
    print "Desired Fan Duty Cycle: $desired_fan_speed%\n";


    # Output basic InfluxDB metrics to /tmp/fan_speed_telegraf
    my $speed_raw = sprintf("%x", $calculated_speed);
    open(FH, '>', '/tmp/fan_speed_telegraf') or die $!;
    print FH "fans,host=$hostname speed_percent=$calculated_speed\n";
    print FH "fans,host=$hostname speed_raw=$speed_raw\n";
    close(FH);
    
    SetFanSpeed($desired_fan_speed);

    # Attempt to detect and mitigate controller overrides
    CheckForOverride($desired_fan_speed);

    # Periodic diagnostics for troubleshooting
    MaybeEmitDiagnostics();
}

print "Starting.\n";
CalculateScalars();

while( 1 )
{
    print "\n";
    print "\n";
    print "\n";
    print "\n";
    print "\n";
    print "=================================================================\n";
    print "Calling UpdateFanSpeed()...\n";
    print "=================================================================\n";
    UpdateFanSpeed();
    print "=================================================================\n";
    print "Update Complete - going to sleep for $seconds_to_sleep seconds...\n";
    print "=================================================================\n";


    sleep $seconds_to_sleep;
}
